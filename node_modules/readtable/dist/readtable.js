'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});


/*
 * 1. { key, mode: 'terminating', action } - creates a delimiter must return an Array/List
 * 2. { key, mode: 'non-terminating', action } - must return a Token or null/undefined. null/undefined simply consumes the read charstream.
 * 3. { key, mode: 'dispatch', action } - triggered by reading #. otherwise like 2
 * 4. { key: null | undefined, mode: 'non-terminating', action } - sets the default behavior for unmatched characters (identifiers/numbers)
 */

const DISPATCH_OFFSET = 0x110000;

class Readtable {
  constructor(entries = []) {
    this._entries = entries;
  }

  getMapping(key) {
    if (!isValidKey(key)) throw Error('Invalid key type:', key);
    key = convertKey(key);
    const { action, mode } = this._entries[key] || this._entries[0];
    const dispatchEntry = this._entries[key + DISPATCH_OFFSET] || this._entries[DISPATCH_OFFSET] || {};
    return { action, mode, dispatchAction: dispatchEntry.action };
  }

  extend(...entries) {
    const newTable = this._entries.slice();
    return new Readtable(entries.reduce(addEntry, newTable));
  }
}

exports.default = Readtable;
function addEntry(table, { key, mode, action }) {
  if (!isValidEntry({ key, mode, action })) throw Error('Invalid readtable entry:', { key, mode, action });

  // null/undefined key is the default and will be converted to 0
  // chars will be converted via codePointAt
  // numbers are...numbers
  // to accommodate default (null) 1 will be added to all and default will be at 0
  // if is a dispatch macro, we have to convert the key and bump it up by DISPATCH_OFFSET
  table[convertKey(key) + (mode === 'dispatch' ? DISPATCH_OFFSET : 0)] = { action, mode };

  return table;
}

const EmptyReadtable = exports.EmptyReadtable = new Readtable([{
  mode: 'non-terminating',
  action: function defaultAction() {
    throw Error('A default readtable entry must be added');
  }
}]);

function isValidKey(key) {
  return key == null || typeof key === 'number' && key < DISPATCH_OFFSET || typeof key === 'string' && key.length >= 0 && key.length <= 2;
}

function isValidMode(mode) {
  return mode === 'terminating' || mode === 'non-terminating' || mode === 'dispatch';
}

function isValidAction(action) {
  return typeof action === 'function';
}

function isValidEntry(entry) {
  return entry && isValidKey(entry.key) && isValidMode(entry.mode) && isValidAction(entry.action);
}

function convertKey(key) {
  return key == null ? 0 : (typeof key === 'number' ? key : key.codePointAt(0)) + 1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWFkdGFibGUuanMiXSwibmFtZXMiOlsiRElTUEFUQ0hfT0ZGU0VUIiwiUmVhZHRhYmxlIiwiY29uc3RydWN0b3IiLCJlbnRyaWVzIiwiX2VudHJpZXMiLCJnZXRNYXBwaW5nIiwia2V5IiwiaXNWYWxpZEtleSIsIkVycm9yIiwiY29udmVydEtleSIsImFjdGlvbiIsIm1vZGUiLCJkaXNwYXRjaEVudHJ5IiwiZGlzcGF0Y2hBY3Rpb24iLCJleHRlbmQiLCJuZXdUYWJsZSIsInNsaWNlIiwicmVkdWNlIiwiYWRkRW50cnkiLCJ0YWJsZSIsImlzVmFsaWRFbnRyeSIsIkVtcHR5UmVhZHRhYmxlIiwiZGVmYXVsdEFjdGlvbiIsImxlbmd0aCIsImlzVmFsaWRNb2RlIiwiaXNWYWxpZEFjdGlvbiIsImVudHJ5IiwiY29kZVBvaW50QXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7Ozs7OztBQU9BLE1BQU1BLGtCQUFrQixRQUF4Qjs7QUFvQmUsTUFBTUMsU0FBTixDQUFnQjtBQUU3QkMsY0FBWUMsVUFBaUMsRUFBN0MsRUFBaUQ7QUFDL0MsU0FBS0MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDRDs7QUFFREUsYUFBV0MsR0FBWCxFQUFpRDtBQUMvQyxRQUFJLENBQUNDLFdBQVdELEdBQVgsQ0FBTCxFQUFzQixNQUFNRSxNQUFNLG1CQUFOLEVBQTJCRixHQUEzQixDQUFOO0FBQ3RCQSxVQUFNRyxXQUFXSCxHQUFYLENBQU47QUFDQSxVQUFNLEVBQUVJLE1BQUYsRUFBVUMsSUFBVixLQUFtQixLQUFLUCxRQUFMLENBQWNFLEdBQWQsS0FBc0IsS0FBS0YsUUFBTCxDQUFjLENBQWQsQ0FBL0M7QUFDQSxVQUFNUSxnQkFBZ0IsS0FBS1IsUUFBTCxDQUFjRSxNQUFNTixlQUFwQixLQUF3QyxLQUFLSSxRQUFMLENBQWNKLGVBQWQsQ0FBeEMsSUFBMEUsRUFBaEc7QUFDQSxXQUFPLEVBQUVVLE1BQUYsRUFBVUMsSUFBVixFQUFnQkUsZ0JBQWdCRCxjQUFjRixNQUE5QyxFQUFQO0FBQ0Q7O0FBRURJLFNBQU8sR0FBR1gsT0FBVixFQUFxRDtBQUNuRCxVQUFNWSxXQUFXLEtBQUtYLFFBQUwsQ0FBY1ksS0FBZCxFQUFqQjtBQUNBLFdBQU8sSUFBSWYsU0FBSixDQUFjRSxRQUFRYyxNQUFSLENBQWVDLFFBQWYsRUFBeUJILFFBQXpCLENBQWQsQ0FBUDtBQUNEO0FBakI0Qjs7a0JBQVZkLFM7QUFvQnJCLFNBQVNpQixRQUFULENBQWtCQyxLQUFsQixFQUFnRCxFQUFFYixHQUFGLEVBQU9LLElBQVAsRUFBYUQsTUFBYixFQUFoRCxFQUE4RztBQUM1RyxNQUFJLENBQUNVLGFBQWEsRUFBQ2QsR0FBRCxFQUFNSyxJQUFOLEVBQVlELE1BQVosRUFBYixDQUFMLEVBQXdDLE1BQU1GLE1BQU0sMEJBQU4sRUFBa0MsRUFBQ0YsR0FBRCxFQUFNSyxJQUFOLEVBQVlELE1BQVosRUFBbEMsQ0FBTjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBUyxRQUFNVixXQUFXSCxHQUFYLEtBQW1CSyxTQUFTLFVBQVQsR0FBc0JYLGVBQXRCLEdBQXdDLENBQTNELENBQU4sSUFBdUUsRUFBRVUsTUFBRixFQUFVQyxJQUFWLEVBQXZFOztBQUVBLFNBQU9RLEtBQVA7QUFDRDs7QUFFTSxNQUFNRSwwQ0FBaUIsSUFBSXBCLFNBQUosQ0FBYyxDQUFDO0FBQzNDVSxRQUFNLGlCQURxQztBQUUzQ0QsVUFBUSxTQUFTWSxhQUFULEdBQXlCO0FBQy9CLFVBQU1kLE1BQU0seUNBQU4sQ0FBTjtBQUNEO0FBSjBDLENBQUQsQ0FBZCxDQUF2Qjs7QUFPUCxTQUFTRCxVQUFULENBQW9CRCxHQUFwQixFQUF5QjtBQUN2QixTQUFPQSxPQUFPLElBQVAsSUFDSixPQUFPQSxHQUFQLEtBQWUsUUFBZixJQUEyQkEsTUFBTU4sZUFEN0IsSUFFSixPQUFPTSxHQUFQLEtBQWUsUUFBZixJQUE0QkEsSUFBSWlCLE1BQUosSUFBYyxDQUFkLElBQW1CakIsSUFBSWlCLE1BQUosSUFBYyxDQUZoRTtBQUdEOztBQUVELFNBQVNDLFdBQVQsQ0FBcUJiLElBQXJCLEVBQTRDO0FBQzFDLFNBQU9BLFNBQVMsYUFBVCxJQUEwQkEsU0FBUyxpQkFBbkMsSUFBd0RBLFNBQVMsVUFBeEU7QUFDRDs7QUFFRCxTQUFTYyxhQUFULENBQXVCZixNQUF2QixFQUErQjtBQUM3QixTQUFPLE9BQU9BLE1BQVAsS0FBa0IsVUFBekI7QUFDRDs7QUFFRCxTQUFTVSxZQUFULENBQXNCTSxLQUF0QixFQUE2QztBQUMzQyxTQUFPQSxTQUFTbkIsV0FBV21CLE1BQU1wQixHQUFqQixDQUFULElBQWtDa0IsWUFBWUUsTUFBTWYsSUFBbEIsQ0FBbEMsSUFBNkRjLGNBQWNDLE1BQU1oQixNQUFwQixDQUFwRTtBQUNEOztBQUVELFNBQVNELFVBQVQsQ0FBb0JILEdBQXBCLEVBQWdEO0FBQzlDLFNBQU9BLE9BQU8sSUFBUCxHQUFjLENBQWQsR0FBa0IsQ0FBQyxPQUFPQSxHQUFQLEtBQWUsUUFBZixHQUEwQkEsR0FBMUIsR0FBZ0NBLElBQUlxQixXQUFKLENBQWdCLENBQWhCLENBQWpDLElBQXVELENBQWhGO0FBQ0QiLCJmaWxlIjoicmVhZHRhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuLypcbiAqIDEuIHsga2V5LCBtb2RlOiAndGVybWluYXRpbmcnLCBhY3Rpb24gfSAtIGNyZWF0ZXMgYSBkZWxpbWl0ZXIgbXVzdCByZXR1cm4gYW4gQXJyYXkvTGlzdFxuICogMi4geyBrZXksIG1vZGU6ICdub24tdGVybWluYXRpbmcnLCBhY3Rpb24gfSAtIG11c3QgcmV0dXJuIGEgVG9rZW4gb3IgbnVsbC91bmRlZmluZWQuIG51bGwvdW5kZWZpbmVkIHNpbXBseSBjb25zdW1lcyB0aGUgcmVhZCBjaGFyc3RyZWFtLlxuICogMy4geyBrZXksIG1vZGU6ICdkaXNwYXRjaCcsIGFjdGlvbiB9IC0gdHJpZ2dlcmVkIGJ5IHJlYWRpbmcgIy4gb3RoZXJ3aXNlIGxpa2UgMlxuICogNC4geyBrZXk6IG51bGwgfCB1bmRlZmluZWQsIG1vZGU6ICdub24tdGVybWluYXRpbmcnLCBhY3Rpb24gfSAtIHNldHMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIHVubWF0Y2hlZCBjaGFyYWN0ZXJzIChpZGVudGlmaWVycy9udW1iZXJzKVxuICovXG5cbmNvbnN0IERJU1BBVENIX09GRlNFVCA9IDB4MTEwMDAwO1xuXG50eXBlIFJlYWR0YWJsZUtleSA9IHN0cmluZyB8IG51bWJlciB8IG51bGw7XG5cbnR5cGUgQWN0aW9uID0gKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IGFueTtcblxudHlwZSBSZWFkdGFibGVNb2RlID0gJ3Rlcm1pbmF0aW5nJyB8ICdub24tdGVybWluYXRpbmcnIHwgJ2Rpc3BhdGNoJztcblxudHlwZSBSZWFkdGFibGVFbnRyeSA9IHtcbiAga2V5PzogP1JlYWR0YWJsZUtleSxcbiAgbW9kZTogUmVhZHRhYmxlTW9kZSxcbiAgYWN0aW9uOiBBY3Rpb25cbn07XG5cbnR5cGUgUmVhZHRhYmxlTWFwcGluZyA9IHtcbiAgbW9kZTogUmVhZHRhYmxlTW9kZSxcbiAgYWN0aW9uOiBBY3Rpb24sXG4gIGRpc3BhdGNoQWN0aW9uOiBBY3Rpb25cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWR0YWJsZSB7XG4gIF9lbnRyaWVzOiBBcnJheTxSZWFkdGFibGVFbnRyeT47XG4gIGNvbnN0cnVjdG9yKGVudHJpZXM6IEFycmF5PFJlYWR0YWJsZUVudHJ5PiA9IFtdKSB7XG4gICAgdGhpcy5fZW50cmllcyA9IGVudHJpZXM7XG4gIH1cblxuICBnZXRNYXBwaW5nKGtleT86IFJlYWR0YWJsZUtleSk6IFJlYWR0YWJsZU1hcHBpbmcge1xuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB0aHJvdyBFcnJvcignSW52YWxpZCBrZXkgdHlwZTonLCBrZXkpO1xuICAgIGtleSA9IGNvbnZlcnRLZXkoa2V5KTtcbiAgICBjb25zdCB7IGFjdGlvbiwgbW9kZSB9ID0gdGhpcy5fZW50cmllc1trZXldIHx8IHRoaXMuX2VudHJpZXNbMF07XG4gICAgY29uc3QgZGlzcGF0Y2hFbnRyeSA9IHRoaXMuX2VudHJpZXNba2V5ICsgRElTUEFUQ0hfT0ZGU0VUXSB8fCB0aGlzLl9lbnRyaWVzW0RJU1BBVENIX09GRlNFVF0gfHwge307XG4gICAgcmV0dXJuIHsgYWN0aW9uLCBtb2RlLCBkaXNwYXRjaEFjdGlvbjogZGlzcGF0Y2hFbnRyeS5hY3Rpb24gfTtcbiAgfVxuXG4gIGV4dGVuZCguLi5lbnRyaWVzOiBBcnJheTxSZWFkdGFibGVFbnRyeT4pOiBSZWFkdGFibGUge1xuICAgIGNvbnN0IG5ld1RhYmxlID0gdGhpcy5fZW50cmllcy5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgUmVhZHRhYmxlKGVudHJpZXMucmVkdWNlKGFkZEVudHJ5LCBuZXdUYWJsZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEVudHJ5KHRhYmxlOiBBcnJheTxSZWFkdGFibGVFbnRyeT4sIHsga2V5LCBtb2RlLCBhY3Rpb24gfTogUmVhZHRhYmxlRW50cnkpOiBBcnJheTxSZWFkdGFibGVFbnRyeT4ge1xuICBpZiAoIWlzVmFsaWRFbnRyeSh7a2V5LCBtb2RlLCBhY3Rpb259KSkgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVhZHRhYmxlIGVudHJ5OicsIHtrZXksIG1vZGUsIGFjdGlvbn0pO1xuXG4gIC8vIG51bGwvdW5kZWZpbmVkIGtleSBpcyB0aGUgZGVmYXVsdCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gMFxuICAvLyBjaGFycyB3aWxsIGJlIGNvbnZlcnRlZCB2aWEgY29kZVBvaW50QXRcbiAgLy8gbnVtYmVycyBhcmUuLi5udW1iZXJzXG4gIC8vIHRvIGFjY29tbW9kYXRlIGRlZmF1bHQgKG51bGwpIDEgd2lsbCBiZSBhZGRlZCB0byBhbGwgYW5kIGRlZmF1bHQgd2lsbCBiZSBhdCAwXG4gIC8vIGlmIGlzIGEgZGlzcGF0Y2ggbWFjcm8sIHdlIGhhdmUgdG8gY29udmVydCB0aGUga2V5IGFuZCBidW1wIGl0IHVwIGJ5IERJU1BBVENIX09GRlNFVFxuICB0YWJsZVtjb252ZXJ0S2V5KGtleSkgKyAobW9kZSA9PT0gJ2Rpc3BhdGNoJyA/IERJU1BBVENIX09GRlNFVCA6IDApXSA9IHsgYWN0aW9uLCBtb2RlIH07XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG5leHBvcnQgY29uc3QgRW1wdHlSZWFkdGFibGUgPSBuZXcgUmVhZHRhYmxlKFt7XG4gIG1vZGU6ICdub24tdGVybWluYXRpbmcnLFxuICBhY3Rpb246IGZ1bmN0aW9uIGRlZmF1bHRBY3Rpb24oKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0EgZGVmYXVsdCByZWFkdGFibGUgZW50cnkgbXVzdCBiZSBhZGRlZCcpO1xuICB9XG59XSk7XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkgPT0gbnVsbCB8fFxuICAgICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiBrZXkgPCBESVNQQVRDSF9PRkZTRVQpIHx8XG4gICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIChrZXkubGVuZ3RoID49IDAgJiYga2V5Lmxlbmd0aCA8PSAyKSk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRNb2RlKG1vZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gbW9kZSA9PT0gJ3Rlcm1pbmF0aW5nJyB8fCBtb2RlID09PSAnbm9uLXRlcm1pbmF0aW5nJyB8fCBtb2RlID09PSAnZGlzcGF0Y2gnO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVudHJ5KGVudHJ5OiBSZWFkdGFibGVFbnRyeSkge1xuICByZXR1cm4gZW50cnkgJiYgaXNWYWxpZEtleShlbnRyeS5rZXkpICYmIGlzVmFsaWRNb2RlKGVudHJ5Lm1vZGUpICYmIGlzVmFsaWRBY3Rpb24oZW50cnkuYWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gY29udmVydEtleShrZXk/OiBSZWFkdGFibGVLZXkpOiBudW1iZXIge1xuICByZXR1cm4ga2V5ID09IG51bGwgPyAwIDogKHR5cGVvZiBrZXkgPT09ICdudW1iZXInID8ga2V5IDoga2V5LmNvZGVQb2ludEF0KDApKSArIDE7XG59XG4iXX0=